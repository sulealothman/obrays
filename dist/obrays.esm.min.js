var t={d:(e,s)=>{for(var r in s)t.o(s,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:s[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e)},e={};t.d(e,{Z:()=>i});class s extends Object{constructor(t={}){super(),s.assign(this,this.#t(t))}get length(){return s.keys(this).length}$(t){return s.#e(this,t)}$s(t,e){const r=t.split(".").pop();s.#e(this,t,!0)[r]=e}includes(t,e=!1){if(!e)return!!this&&s.keys(this).includes(t);const r=t;t=t.split(".").pop();const i=s.#e(this,r,!0);return!!i&&s.keys(i).includes(t)}static includes(t,e,r=!1){if(!r)return s.keys(t).includes(e);const i=e,n=this.#e(t,i,!0);return e=e.split(".").pop(),!!n&&s.keys(n).includes(e)}remove(t,e=!1){let r=this;if(e){const e=t;t=t.split(".").pop(),r=s.#e(this,e,!0)}r[t]&&delete r[t]}static remove(t,e,s=!1){let r=t;if(s){const s=e;e=e.split(".").pop(),r=this.#e(t,s,!0)}r[e]&&delete r[e]}clone(t){s.assign(this,this.#t(t))}static clone(t){const e=Array.isArray(t)?[]:{};for(const s of Object.keys(t))e[s]="object"!=typeof t[s]?t[s]:this.clone(t[s]);return e}#t(t){const e=Array.isArray(t)?[]:{};for(const r of s.keys(t))e[r]="object"!=typeof t[r]?t[r]:this.#t(t[r]);return e}cloneAsTemplate(t){s.assign(this,this.#s(t))}#s(t){const e=Array.isArray(t)?[]:{};for(const r of s.keys(t))e[r]="object"!=typeof t[r]?void 0:this.#s(t[r]);return e}asJson(t,e){return JSON.stringify(this,t,e)}parse(t,e){return s.assign(this,JSON.parse(t,e))}static isObj(t){return"object"==typeof t&&!Array.isArray(t)&&null!==t}static#e(t,e,s=!1){const r=e.split(".");return s&&r.pop(),r.reduce(((t,e)=>!!t&&t[e]),t)}}class r extends Array{constructor(...t){1===t.length?r.isArray(t[0])?super(...t[0]):"number"==typeof t[0]&&(super(),this.push(t[0])):super(...t)}get size(){return Object.keys(this).length}static size(t){return Object.keys(t).length}get isEmpty(){return!Object.keys(this).length}static isEmpty(t){return!Object.keys(t).length}#r(t){return null!==t&&"object"==typeof t||null!==t&&this.isArray(t)}#i(t,e){const s=this.isArray(t);let r=t,i=e;if(s||(r=Object.keys(t),i=Object.keys(e)),r.length!==i.length)return!1;for(const n in r){if(this.#r(r[n])!==this.#r(i[n]))return!1;if(this.#r(r[n])&&!this.#i(r[n],i[n]))return!1;if(!s&&(r[n]!==i[n]||t[r[n]]!==e[r[n]]))return!1;if(r[n]!==i[n])return!1}return!0}isEqual(t){if(this.length!==t.length)return!1;for(let e in this){if(this.#r(this[e])!==this.#r(t[e]))return!1;if(this.#r(this[e])&&!this.#i(this[e],t[e]))return!1;if(this[e]!==t[e])return!1}return!0}fixed(){let t=this.length||0;for(;t--&&this.includes(void 0);)void 0===this[t]&&this.splice(t,1);return this.length}static fixed(t){if(!this.isArray(t))throw new TypeError(`${Object.keys({arr:t})[0]} unexpected argument`);let e=t.length||0;for(;e--&&t.includes(void 0);)void 0===t[e]&&t.splice(e,1);return t.length}sortBy(t="asc"){"string"==typeof t&&(t=t.toLocaleLowerCase());const e={asc:()=>this.sort(((t,e)=>isNaN(t)||isNaN(e)?t>e?1:-1:t-e)),dsc:()=>this.sort(((t,e)=>isNaN(t)||isNaN(e)?e>t?1:-1:e-t)),alp:()=>this.sort()};if(void 0===e[t])throw new TypeError(`${Object.keys({order:t})[0]} unexpected argument`);return e[t]()}clear(){this.splice(0,this.length)}isArray(t){return r.isArray(t)}remove(t,e=!1){if(!e){let e=this.findIndex((e=>this.#r(t)?this.#i(e,t):e===t));return e>-1&&(this.splice(e,1),!0)}let s=[];if(s=this.#r(t)?this.reduce(((e,s,r)=>this.#i(s,t)?[...e,r]:e),[]):this.reduce(((e,s,r)=>s===t?[...e,r]:e),[]),!s.length)return!1;let r=s.length||0;for(;r--;)this.splice(s[r],1);return!0}}const i={Arr:r,Obj:s};var n=e.Z;export{r as Arr, s as Obj};
//# sourceMappingURL=obrays.esm.min.js.map